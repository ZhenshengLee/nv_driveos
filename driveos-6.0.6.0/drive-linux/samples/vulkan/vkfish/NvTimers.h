//----------------------------------------------------------------------------------
// File:        NvGLUtils/NvTimers.h
// SDK Version: v3.00 
// Email:       gameworks@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//----------------------------------------------------------------------------------
#ifndef NV_TIMERS_H
#define NV_TIMERS_H

#include "NV/NvPlatformGL.h"
#include "KHR/khrplatform.h"

/// \file
/// GPU timers and scope wrappers.

class NvGLExtensionsAPI;

/// Accurate timning of GPU operations.  Because the GPU is a based on an
/// asynchronously processed command stream that is implicitly generated by
/// OpenGL calls, it is not possible to determine the amount of time spent
/// processing a set of OpenGL calls by timing the calls themselves at the
/// application level.  Instead, the timing must be done via an asynchronous
/// timer system.  These timers are started and stopped at the beginning and
/// end of the OpenGL commands of interest.  However, the timings results
/// must be queried at some point later, as the pipeline must complete before
/// the timer values are known.  This class implements a set of multiple
/// timers to allow several start/stop instances to be "in flight"
class NvGPUTimer
{
public:
    /// Creates a stopped, zeroed timer; need not be called with a bound
    /// OpenGL context
    NvGPUTimer()
    : m_elapsedCycles(0.f)
    , m_nextTimeStampQuery(0)
    , m_startStopCycles(0) {
        for (unsigned int i = 0; i < TIMER_COUNT; i++)
            m_timeStampQueryInFlight[i] = false;
    }

    /// Initializes the OpenGL parts of the timer.  This function must be
    /// called from a thread that has the OpenGL context to be used bound
    void init() {
        m_glGenQueries(TIMER_COUNT*TIMESTAMP_QUERY_COUNT, m_queries[0]);
    }

    /// Resets the elapsed time and count of start/stop calls to zero
    void reset() {
        m_elapsedCycles = 0.0f;
        m_startStopCycles = 0;
    }

    /// Starts the timer (the next OpenGL call will be the first timed).
    /// This must be called from a thread with the OpenGL context bound
    void start() {
        getResults();  // add timings from previous start/stop if pending
        m_glQueryCounter(m_queries[m_nextTimeStampQuery][TIMESTAMP_QUERY_BEGIN], NV_TIMESTAMP);
    }

    /// Starts the timer (the previous OpenGL call will be the last timed).
    /// This must be called from a thread with the OpenGL context bound
    void stop() {
        m_glQueryCounter(m_queries[m_nextTimeStampQuery][TIMESTAMP_QUERY_END], NV_TIMESTAMP);
        m_timeStampQueryInFlight[m_nextTimeStampQuery] = true;
    }

    /// Get the number of start/stop cycles whose values have been accumulated
    /// since the last reset.  This value may be lower than the number of call
    /// pairs to start/stop, as this value does not take into account the start/stop
    /// cycles that are still "in flight" (awaiting results).
    /// \return the number of start/stop cycles represented in the current 
    /// accumulated time
    int32_t getStartStopCycles() { 
        return m_startStopCycles; 
    }

    /// Get the amount of time accumulated for start/stop cycles that have completed
    /// since the last reset.  This value may be lower than the time for all call
    /// pairs to start/stop since the last reset, as this value does not take into 
    /// account the start/stop cycles that are still "in flight" (awaiting results).
    /// \return the accumulated time of completed start/stop cycles since the last reset
    float getScaledCycles() {
        getResults();

        return m_elapsedCycles;
    }

    /// Static initialization of the GPU timer extensions.  Must be called with the
    /// intended OpenGL context bound.
    /// \param[in] api the OpenGL extensions retrieval interface object
    static void globalInit(NvGLExtensionsAPI& api);

protected:
    /// \privatesection
    void getResults() {
        // Make a pass over all timers - if any are pending results ("in flight"), then
        // grab the the time diff and add to the accumulator.  Then, mark the timer as 
        // not in flight and record it as a possible next timer to use (since it is
        // now unused)
        int32_t freeQuery = -1;
        for (unsigned int i = 0; i < TIMER_COUNT; i++) {
            // Are we awaiting a result?
            if (m_timeStampQueryInFlight[i]) {
                GLuint available = false;
                m_glGetQueryObjectuiv(m_queries[i][TIMESTAMP_QUERY_END], NV_QUERY_RESULT_AVAILABLE, &available);

                // Is the result ready?
                if (available) {
                    uint64_t timeStart, timeEnd;
                    m_glGetQueryObjectui64v(m_queries[i][TIMESTAMP_QUERY_BEGIN], NV_QUERY_RESULT, &timeStart);
                    m_glGetQueryObjectui64v(m_queries[i][TIMESTAMP_QUERY_END], NV_QUERY_RESULT, &timeEnd);
                
                    // add the time to the accumulator
                    m_elapsedCycles += float(double(timeEnd - timeStart) * 1.e-6);
                    freeQuery = i;
                    m_timeStampQueryInFlight[i] = false;

                    // Increment the counter of start/stop cycles
                    m_startStopCycles++;
                }
            }
        }
        // Use the newly-freed counters if one exists
        // otherwise, swap to the "next" counter
        if (freeQuery >= 0)
        {
            m_nextTimeStampQuery = freeQuery;
        }
        else
        {
            m_nextTimeStampQuery++;
            m_nextTimeStampQuery = (m_nextTimeStampQuery >= TIMER_COUNT) ? 0 : m_nextTimeStampQuery;
        }
    }

    const static unsigned int NV_QUERY_RESULT = 0x8866;
    const static unsigned int NV_QUERY_RESULT_AVAILABLE = 0x8867;
    const static unsigned int NV_TIMESTAMP = 0x8E28;

    typedef void (KHRONOS_APIENTRY* NV_PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
    typedef void (KHRONOS_APIENTRY* NV_PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
    typedef void (KHRONOS_APIENTRY* NV_PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
    typedef void (KHRONOS_APIENTRY* NV_PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, uint64_t *params);

    static NV_PFNGLGENQUERIESPROC          m_glGenQueries;
    static NV_PFNGLQUERYCOUNTERPROC        m_glQueryCounter;
    static NV_PFNGLGETQUERYOBJECTUIVPROC   m_glGetQueryObjectuiv;
    static NV_PFNGLGETQUERYOBJECTUI64VPROC m_glGetQueryObjectui64v;

    const static unsigned int TIMER_COUNT = 4;
    enum {
        TIMESTAMP_QUERY_BEGIN = 0,
        TIMESTAMP_QUERY_END,
        TIMESTAMP_QUERY_COUNT
    };

    GLuint m_queries[TIMER_COUNT][TIMESTAMP_QUERY_COUNT];
    float m_elapsedCycles;
    uint32_t m_nextTimeStampQuery;
    int32_t m_startStopCycles;
    bool m_timeStampQueryInFlight[TIMER_COUNT];
};


/// A helper class that allows for simple "code block" implicit timer
/// start/stops.  The following code:
/// \code
///     {
///         NvGPUTimerScope myScope(myTimer);
///         // ... my block of timed code
///     }
/// \endcode
///
/// Is equivalent to:
/// \code
///     {
///         myTimer->start();
///         // ... my block of timed code
///         myTimer->stop();
///     }
/// \endcode
struct NvGPUTimerScope {
    /// Constructor - starts the given timer
    /// \param [in] timer the timer to be used
    NvGPUTimerScope(NvGPUTimer *timer) : m_timer(timer) { timer->start(); }
    /// Destructor - stops the timer that was passed to the constructor
    ~NvGPUTimerScope() { m_timer->stop(); }
    NvGPUTimer *m_timer;
};


#endif
